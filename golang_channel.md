# **CHANNEL**

**"通道类型的值本身就是并发安全的，这是 Golang 自带的唯一一个可以满足并发安全的类型."**

## **I. Channel 3种类型**

```
chan T // 可用于接收或发送 T 类型的数据
chan<- float64 // 只可用来发送 float64 类型的数据
<-chan int // 只可用来接收 int 类型的数据
```

使用 make 初始化 channel，并且可以设定容量。容量为 channel 可以容纳的最多的元素数量，代表 channel 缓存的大小。  
如果没有设置容量，或者容量设置为0，则说明 channel 没有缓存，只有 sender 和 receiver 都准备好了才可以通讯。  
如果设置了缓存，就有可能不发生阻塞，只有 buffer 满了 send 才会阻塞，只有缓存空了之后 receive 才会阻塞。  
一个 nil channel 不会通信。  

```
make(chan int, 100)
```

可以通过内建方法 close 关闭 channel。  
可以从多个 goroutine 向一个 channel 发送或接收数据，不需要额外考虑同步措施。  
channel 可以作为一个 FIFO 队列，接收数据的顺序和发送数据的顺序是一致的。  
channel 的 receive 支持 multiple assignment:  

```
v, ok := <-cha // 可以用来检查通道是否关闭
```

## **II. channel 发送和接收操作的基本特性**

### **A. 对于同一个 channel，发送操作时间是互斥的，接收操作之间也是互斥的**

同一时刻，golang 的运行时系统只会执行对同一个通道的任意个发送操作中的一个，直到这个元素值被完全复制到该通道之后，其他针对该通道的发送操作才会执行。  
同理，通道的接受操作在同一时刻也只会执行一个。  

**元素值进入通道时会被复制，即进入通道的并不是在接收操作符右边的那个值，而是它的副本。**   
元素从通道进入外界时会发生移动，这个移动操作包含两步，一个是生成这个元素值的副本，并准备给到接收方，下一步是删除通道中这个元素的值。  

### **B. 发送操作和接收操作中对元素的处理都是不可分割的**

发送操作要么还没有复制元素值，要么已经复制完毕，不会出现只复制了一半的情况。  
接收操作在准备好元素的副本之后，一定会删除通道中的原值，绝不会出现通道中仍然有残留的情况。  
通道中的一个元素值，在同一时刻只可能是被某一个发送操作放入的，同时也只可能被一个接收操作取出。 

### **C. 发送操作在完成之前会被阻塞，接收操作也是**

发送操作包含了“复制元素值”和“将复制的副本放到通道内”两步操作，在这两个步骤完成之前，发起发送操作的代码会一直阻塞，即其后的代码不会有执行的机会，直至这句代码的阻塞解除。  
通道完成发送之后，运行时系统会通知这句代码所在的 gorountine，使其之后的代码继续执行。  

接收操作包括了“复制通道内的元素”、“放置副本到接收方”、“删掉原值”三步操作，同样在接收操作执行完之前会阻塞代码。

阻塞代码的目的就是实现操作的互斥和元素值的完整。

### **D. 发送操作和接收操作在什么时候可能会长时间阻塞**

缓冲通道：若通道已满，任何对其的发送操作都会阻塞，直到通道中的元素被取出。
这时，通道会优先通知最早因此阻塞的 goroutine，然后再次执行发送操作。
发送操作在这种情况下被阻塞之后，它们所在的 goroutine 会顺序进入通道内部的发送等待列表，所以通知的顺序总是公平的。  
对通道的接收操作同理。  

非缓冲通道：发送和接收操作在一开始都会阻塞，直至配对的操作也开始执行，才会继续传递，由此可见非缓冲通道是在用同步的方式传递数据。



